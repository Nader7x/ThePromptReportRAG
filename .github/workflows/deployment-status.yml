name: 📊 Deployment Status & Analytics

on:
  schedule:
    # Run daily at 8 AM UTC
    - cron: "0 8 * * *"
  workflow_dispatch:
  push:
    branches: [main]

permissions:
  contents: write

env:
  STREAMLIT_APP_URL: "https://prompt-forge-ai.streamlit.app"

jobs:
  deployment-status:
    runs-on: ubuntu-latest
    name: 📊 Check Deployment Status

    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      - name: 🌐 Check deployment status
        id: status
        run: |
          echo "🌐 Checking deployment status..."

          # Check main app
          app_status=$(curl -s -o /dev/null -w "%{http_code}" ${{ env.STREAMLIT_APP_URL }})
          echo "app_status=$app_status" >> $GITHUB_OUTPUT

          # Get response time
          start_time=$(date +%s%N)
          curl -s ${{ env.STREAMLIT_APP_URL }} > /dev/null
          end_time=$(date +%s%N)
          response_time=$((($end_time - $start_time) / 1000000))
          echo "response_time=$response_time" >> $GITHUB_OUTPUT

          # Check if it's a Streamlit app
          content=$(curl -s ${{ env.STREAMLIT_APP_URL }})
          if echo "$content" | grep -q "streamlit"; then
            echo "streamlit_detected=true" >> $GITHUB_OUTPUT
          else
            echo "streamlit_detected=false" >> $GITHUB_OUTPUT
          fi

      - name: 📊 Generate status report
        run: |
          cat > deployment_report.md << 'EOF'
          # 📊 Deployment Status Report

          **Generated:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')
          **Repository:** ${{ github.repository }}
          **Branch:** ${{ github.ref_name }}
          **Commit:** ${{ github.sha }}

          ## 🌐 Application Status

          | Service | Status | Response Time | Details |
          |---------|--------|---------------|---------|
          | Streamlit App | ${{ steps.status.outputs.app_status == '200' && '🟢 Online' || '🔴 Offline' }} | ${{ steps.status.outputs.response_time }}ms | [${{ env.STREAMLIT_APP_URL }}](${{ env.STREAMLIT_APP_URL }}) |

          ## 🔍 Health Metrics

          - **HTTP Status Code:** ${{ steps.status.outputs.app_status }}
          - **Response Time:** ${{ steps.status.outputs.response_time }}ms
          - **Streamlit Framework:** ${{ steps.status.outputs.streamlit_detected == 'true' && '✅ Detected' || '❌ Not Detected' }}
          - **Last Check:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')

          ## 📈 Performance Rating

          EOF

          # Add performance rating
          response_time=${{ steps.status.outputs.response_time }}
          if [ $response_time -lt 2000 ]; then
            echo "🚀 **Excellent** - Response time under 2 seconds" >> deployment_report.md
          elif [ $response_time -lt 5000 ]; then
            echo "✅ **Good** - Response time under 5 seconds" >> deployment_report.md
          elif [ $response_time -lt 10000 ]; then
            echo "⚠️ **Acceptable** - Response time under 10 seconds" >> deployment_report.md
          else
            echo "❌ **Poor** - Response time over 10 seconds" >> deployment_report.md
          fi

          cat >> deployment_report.md << 'EOF'

          ## 🔧 Quick Actions

          - 🔄 [Redeploy App](https://share.streamlit.io/)
          - 📊 [View Logs](https://share.streamlit.io/)
          - 🏥 [Run Health Check](../../actions/workflows/health-check.yml)
          - 🐳 [Deploy via Docker](../../actions/workflows/docker-publish.yml)

          ## 📋 Recent Activity

          EOF

          # Add recent commits
          echo "### Latest Commits" >> deployment_report.md
          echo "" >> deployment_report.md
          git log --oneline -5 --pretty=format:"- \`%h\` %s (%cr)" >> deployment_report.md
          echo "" >> deployment_report.md

          # Show the report
          cat deployment_report.md

      - name: 💾 Update status file
        run: |
          # Create/update status file
          mkdir -p .github/status
          cp deployment_report.md .github/status/latest_deployment_status.md

          # Add timestamp
          echo "last_updated: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" > .github/status/status.yml
          echo "app_status: ${{ steps.status.outputs.app_status }}" >> .github/status/status.yml
          echo "response_time: ${{ steps.status.outputs.response_time }}" >> .github/status/status.yml
          echo "streamlit_detected: ${{ steps.status.outputs.streamlit_detected }}" >> .github/status/status.yml

      - name: � Pull latest changes
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git pull origin main --rebase --autostash

      - name: �📤 Commit status update
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "📊 Update deployment status [skip ci]"
          file_pattern: ".github/status/*"

      - name: 📋 Add to summary
        run: |
          echo "## 📊 Deployment Status Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          cat deployment_report.md >> $GITHUB_STEP_SUMMARY

  performance-benchmark:
    runs-on: ubuntu-latest
    name: ⚡ Performance Benchmark
    if: github.event_name == 'workflow_dispatch'

    steps:
      - name: ⚡ Run performance tests
        run: |
          echo "⚡ Running performance benchmark..."

          # Multiple response time measurements
          declare -a times
          total=0

          for i in {1..10}; do
            start_time=$(date +%s%N)
            curl -s ${{ env.STREAMLIT_APP_URL }} > /dev/null
            end_time=$(date +%s%N)
            response_time=$((($end_time - $start_time) / 1000000))
            times+=($response_time)
            total=$((total + response_time))
            echo "🔄 Test $i: ${response_time}ms"
          done

          # Calculate statistics
          avg=$((total / 10))

          # Find min and max
          min=${times[0]}
          max=${times[0]}
          for time in "${times[@]}"; do
            [ $time -lt $min ] && min=$time
            [ $time -gt $max ] && max=$time
          done

          echo "## ⚡ Performance Benchmark Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Average Response Time | ${avg}ms |" >> $GITHUB_STEP_SUMMARY
          echo "| Minimum Response Time | ${min}ms |" >> $GITHUB_STEP_SUMMARY
          echo "| Maximum Response Time | ${max}ms |" >> $GITHUB_STEP_SUMMARY
          echo "| Total Tests | 10 |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Performance grade
          if [ $avg -lt 1000 ]; then
            echo "**Performance Grade: A+ 🏆**" >> $GITHUB_STEP_SUMMARY
          elif [ $avg -lt 2000 ]; then
            echo "**Performance Grade: A 🥇**" >> $GITHUB_STEP_SUMMARY
          elif [ $avg -lt 3000 ]; then
            echo "**Performance Grade: B 🥈**" >> $GITHUB_STEP_SUMMARY
          elif [ $avg -lt 5000 ]; then
            echo "**Performance Grade: C 🥉**" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Performance Grade: D ⚠️**" >> $GITHUB_STEP_SUMMARY
          fi

  update-readme-status:
    runs-on: ubuntu-latest
    name: 📝 Update README Status
    needs: [deployment-status]
    if: github.ref == 'refs/heads/main'

    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      - name: 🔍 Check current status
        id: check
        run: |
          # Check deployment status
          app_status=$(curl -s -o /dev/null -w "%{http_code}" ${{ env.STREAMLIT_APP_URL }})
          echo "app_status=$app_status" >> $GITHUB_OUTPUT

          if [ "$app_status" = "200" ]; then
            echo "status_badge=🟢%20Online" >> $GITHUB_OUTPUT
            echo "status_text=Online" >> $GITHUB_OUTPUT
          else
            echo "status_badge=🔴%20Offline" >> $GITHUB_OUTPUT
            echo "status_text=Offline" >> $GITHUB_OUTPUT
          fi

      - name: 📝 Update README badges
        run: |
          # Create status badge URL
          badge_url="https://img.shields.io/badge/App%20Status-${{ steps.check.outputs.status_badge }}-brightgreen"

          # Update README if it exists
          if [ -f "README.md" ]; then
            # Add deployment status section if it doesn't exist
            if ! grep -q "## 🚀 Deployment Status" README.md; then
              cat >> README.md << EOF

          ## 🚀 Deployment Status

          ![App Status](${badge_url})

          - **Live App**: [${{ env.STREAMLIT_APP_URL }}](${{ env.STREAMLIT_APP_URL }})
          - **Status**: ${{ steps.check.outputs.status_text }}
          - **Last Updated**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')

          EOF
            fi
          fi

      - name: � Pull latest changes before README update
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git pull origin main --rebase --autostash

      - name: �💾 Commit README update
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "📝 Update deployment status badge [skip ci]"
          file_pattern: "README.md"
