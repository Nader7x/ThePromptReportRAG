name: ðŸ“Š Deployment Status & Analytics

on:
  schedule:
    # Run daily at 8 AM UTC
    - cron: "0 8 * * *"
  workflow_dispatch:
  push:
    branches: [main]

permissions:
  contents: write

env:
  STREAMLIT_APP_URL: "https://prompt-forge-ai.streamlit.app"

jobs:
  deployment-status:
    runs-on: ubuntu-latest
    name: ðŸ“Š Check Deployment Status

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸŒ Check deployment status
        id: status
        run: |
          echo "ðŸŒ Checking deployment status..."

          # Check main app
          app_status=$(curl -s -o /dev/null -w "%{http_code}" ${{ env.STREAMLIT_APP_URL }})
          echo "app_status=$app_status" >> $GITHUB_OUTPUT

          # Get response time
          start_time=$(date +%s%N)
          curl -s ${{ env.STREAMLIT_APP_URL }} > /dev/null
          end_time=$(date +%s%N)
          response_time=$((($end_time - $start_time) / 1000000))
          echo "response_time=$response_time" >> $GITHUB_OUTPUT

          # Check if it's a Streamlit app
          content=$(curl -s ${{ env.STREAMLIT_APP_URL }})
          if echo "$content" | grep -q "streamlit"; then
            echo "streamlit_detected=true" >> $GITHUB_OUTPUT
          else
            echo "streamlit_detected=false" >> $GITHUB_OUTPUT
          fi

      - name: ðŸ“Š Generate status report
        run: |
          cat > deployment_report.md << 'EOF'
          # ðŸ“Š Deployment Status Report

          **Generated:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')
          **Repository:** ${{ github.repository }}
          **Branch:** ${{ github.ref_name }}
          **Commit:** ${{ github.sha }}

          ## ðŸŒ Application Status

          | Service | Status | Response Time | Details |
          |---------|--------|---------------|---------|
          | Streamlit App | ${{ steps.status.outputs.app_status == '200' && 'ðŸŸ¢ Online' || 'ðŸ”´ Offline' }} | ${{ steps.status.outputs.response_time }}ms | [${{ env.STREAMLIT_APP_URL }}](${{ env.STREAMLIT_APP_URL }}) |

          ## ðŸ” Health Metrics

          - **HTTP Status Code:** ${{ steps.status.outputs.app_status }}
          - **Response Time:** ${{ steps.status.outputs.response_time }}ms
          - **Streamlit Framework:** ${{ steps.status.outputs.streamlit_detected == 'true' && 'âœ… Detected' || 'âŒ Not Detected' }}
          - **Last Check:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')

          ## ðŸ“ˆ Performance Rating

          EOF

          # Add performance rating
          response_time=${{ steps.status.outputs.response_time }}
          if [ $response_time -lt 2000 ]; then
            echo "ðŸš€ **Excellent** - Response time under 2 seconds" >> deployment_report.md
          elif [ $response_time -lt 5000 ]; then
            echo "âœ… **Good** - Response time under 5 seconds" >> deployment_report.md
          elif [ $response_time -lt 10000 ]; then
            echo "âš ï¸ **Acceptable** - Response time under 10 seconds" >> deployment_report.md
          else
            echo "âŒ **Poor** - Response time over 10 seconds" >> deployment_report.md
          fi

          cat >> deployment_report.md << 'EOF'

          ## ðŸ”§ Quick Actions

          - ðŸ”„ [Redeploy App](https://share.streamlit.io/)
          - ðŸ“Š [View Logs](https://share.streamlit.io/)
          - ðŸ¥ [Run Health Check](../../actions/workflows/health-check.yml)
          - ðŸ³ [Deploy via Docker](../../actions/workflows/docker-publish.yml)

          ## ðŸ“‹ Recent Activity

          EOF

          # Add recent commits
          echo "### Latest Commits" >> deployment_report.md
          echo "" >> deployment_report.md
          git log --oneline -5 --pretty=format:"- \`%h\` %s (%cr)" >> deployment_report.md
          echo "" >> deployment_report.md

          # Show the report
          cat deployment_report.md

      - name: ðŸ’¾ Update status file
        run: |
          # Create/update status file
          mkdir -p .github/status
          cp deployment_report.md .github/status/latest_deployment_status.md

          # Add timestamp
          echo "last_updated: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" > .github/status/status.yml
          echo "app_status: ${{ steps.status.outputs.app_status }}" >> .github/status/status.yml
          echo "response_time: ${{ steps.status.outputs.response_time }}" >> .github/status/status.yml
          echo "streamlit_detected: ${{ steps.status.outputs.streamlit_detected }}" >> .github/status/status.yml

      - name: ï¿½ Pull latest changes
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git pull origin main --rebase --autostash

      - name: ï¿½ðŸ“¤ Commit status update
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "ðŸ“Š Update deployment status [skip ci]"
          file_pattern: ".github/status/*"

      - name: ðŸ“‹ Add to summary
        run: |
          echo "## ðŸ“Š Deployment Status Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          cat deployment_report.md >> $GITHUB_STEP_SUMMARY

  performance-benchmark:
    runs-on: ubuntu-latest
    name: âš¡ Performance Benchmark
    if: github.event_name == 'workflow_dispatch'

    steps:
      - name: âš¡ Run performance tests
        run: |
          echo "âš¡ Running performance benchmark..."

          # Multiple response time measurements
          declare -a times
          total=0

          for i in {1..10}; do
            start_time=$(date +%s%N)
            curl -s ${{ env.STREAMLIT_APP_URL }} > /dev/null
            end_time=$(date +%s%N)
            response_time=$((($end_time - $start_time) / 1000000))
            times+=($response_time)
            total=$((total + response_time))
            echo "ðŸ”„ Test $i: ${response_time}ms"
          done

          # Calculate statistics
          avg=$((total / 10))

          # Find min and max
          min=${times[0]}
          max=${times[0]}
          for time in "${times[@]}"; do
            [ $time -lt $min ] && min=$time
            [ $time -gt $max ] && max=$time
          done

          echo "## âš¡ Performance Benchmark Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Average Response Time | ${avg}ms |" >> $GITHUB_STEP_SUMMARY
          echo "| Minimum Response Time | ${min}ms |" >> $GITHUB_STEP_SUMMARY
          echo "| Maximum Response Time | ${max}ms |" >> $GITHUB_STEP_SUMMARY
          echo "| Total Tests | 10 |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Performance grade
          if [ $avg -lt 1000 ]; then
            echo "**Performance Grade: A+ ðŸ†**" >> $GITHUB_STEP_SUMMARY
          elif [ $avg -lt 2000 ]; then
            echo "**Performance Grade: A ðŸ¥‡**" >> $GITHUB_STEP_SUMMARY
          elif [ $avg -lt 3000 ]; then
            echo "**Performance Grade: B ðŸ¥ˆ**" >> $GITHUB_STEP_SUMMARY
          elif [ $avg -lt 5000 ]; then
            echo "**Performance Grade: C ðŸ¥‰**" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Performance Grade: D âš ï¸**" >> $GITHUB_STEP_SUMMARY
          fi

  update-readme-status:
    runs-on: ubuntu-latest
    name: ðŸ“ Update README Status
    needs: [deployment-status]
    if: github.ref == 'refs/heads/main'

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸ” Check current status
        id: check
        run: |
          # Check deployment status
          app_status=$(curl -s -o /dev/null -w "%{http_code}" ${{ env.STREAMLIT_APP_URL }})
          echo "app_status=$app_status" >> $GITHUB_OUTPUT

          if [ "$app_status" = "200" ]; then
            echo "status_badge=ðŸŸ¢%20Online" >> $GITHUB_OUTPUT
            echo "status_text=Online" >> $GITHUB_OUTPUT
          else
            echo "status_badge=ðŸ”´%20Offline" >> $GITHUB_OUTPUT
            echo "status_text=Offline" >> $GITHUB_OUTPUT
          fi

      - name: ðŸ“ Update README badges
        run: |
          # Create status badge URL
          badge_url="https://img.shields.io/badge/App%20Status-${{ steps.check.outputs.status_badge }}-brightgreen"

          # Update README if it exists
          if [ -f "README.md" ]; then
            # Add deployment status section if it doesn't exist
            if ! grep -q "## ðŸš€ Deployment Status" README.md; then
              cat >> README.md << EOF

          ## ðŸš€ Deployment Status

          ![App Status](${badge_url})

          - **Live App**: [${{ env.STREAMLIT_APP_URL }}](${{ env.STREAMLIT_APP_URL }})
          - **Status**: ${{ steps.check.outputs.status_text }}
          - **Last Updated**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')

          EOF
            fi
          fi

      - name: ï¿½ Pull latest changes before README update
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git pull origin main --rebase --autostash

      - name: ï¿½ðŸ’¾ Commit README update
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "ðŸ“ Update deployment status badge [skip ci]"
          file_pattern: "README.md"
